<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Liquid Glass Effect</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            overflow: hidden;
        }

        .canvas-container {
            position: relative;
            width: 800px;
            height: 600px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="glCanvas"></canvas>
    </div>

    <script>
        // Vertex shader for all passes
        const vertexShaderSource = `#version 300 es
            in vec4 a_position;
            in vec2 a_texCoord;
            
            out vec2 v_texCoord;
            
            void main() {
                gl_Position = a_position;
                v_texCoord = a_texCoord;
            }
        `;

        // Background pass fragment shader
        const fragmentBgShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform sampler2D u_bgTexture;
            uniform float u_time;
            uniform float u_shadowExpand;
            uniform float u_shadowFactor;
            uniform vec2 u_shadowPosition;
            
            out vec4 fragColor;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec2 mouse = u_mouse / u_resolution;
                
                // Background texture sampling
                vec4 bgColor = texture(u_bgTexture, v_texCoord);
                
                // Shadow calculation
                float shadowDist = length(uv - mouse + u_shadowPosition);
                float shadow = smoothstep(0.5 + u_shadowExpand, 0.0, shadowDist) * u_shadowFactor;
                
                fragColor = mix(bgColor, vec4(0.0, 0.0, 0.0, 1.0), shadow);
            }
        `;

        // Vertical blur pass fragment shader
        const fragmentVBlurShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            uniform sampler2D u_texture;
            uniform vec2 u_resolution;
            uniform float u_blurRadius;
            
            out vec4 fragColor;
            
            void main() {
                vec4 sum = vec4(0.0);
                float blurSize = u_blurRadius / u_resolution.y;
                
                // Gaussian blur weights
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y - 4.0 * blurSize)) * 0.05;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y - 3.0 * blurSize)) * 0.09;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y - 2.0 * blurSize)) * 0.12;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y - blurSize)) * 0.15;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y)) * 0.18;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y + blurSize)) * 0.15;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y + 2.0 * blurSize)) * 0.12;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y + 3.0 * blurSize)) * 0.09;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y + 4.0 * blurSize)) * 0.05;
                
                fragColor = sum;
            }
        `;

        // Horizontal blur pass fragment shader
        const fragmentHBlurShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            uniform sampler2D u_texture;
            uniform vec2 u_resolution;
            uniform float u_blurRadius;
            
            out vec4 fragColor;
            
            void main() {
                vec4 sum = vec4(0.0);
                float blurSize = u_blurRadius / u_resolution.x;
                
                // Gaussian blur weights
                sum += texture(u_texture, vec2(v_texCoord.x - 4.0 * blurSize, v_texCoord.y)) * 0.05;
                sum += texture(u_texture, vec2(v_texCoord.x - 3.0 * blurSize, v_texCoord.y)) * 0.09;
                sum += texture(u_texture, vec2(v_texCoord.x - 2.0 * blurSize, v_texCoord.y)) * 0.12;
                sum += texture(u_texture, vec2(v_texCoord.x - blurSize, v_texCoord.y)) * 0.15;
                sum += texture(u_texture, vec2(v_texCoord.x, v_texCoord.y)) * 0.18;
                sum += texture(u_texture, vec2(v_texCoord.x + blurSize, v_texCoord.y)) * 0.15;
                sum += texture(u_texture, vec2(v_texCoord.x + 2.0 * blurSize, v_texCoord.y)) * 0.12;
                sum += texture(u_texture, vec2(v_texCoord.x + 3.0 * blurSize, v_texCoord.y)) * 0.09;
                sum += texture(u_texture, vec2(v_texCoord.x + 4.0 * blurSize, v_texCoord.y)) * 0.05;
                
                fragColor = sum;
            }
        `;

        // Main pass fragment shader (glass effect)
        const fragmentMainShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            uniform sampler2D u_blurredBg;
            uniform sampler2D u_bg;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform vec2 u_mouseSpring;
            uniform float u_time;
            uniform vec4 u_tint;
            uniform float u_refFactor;
            uniform float u_refDispersion;
            uniform float u_refFresnelRange;
            uniform float u_refFresnelFactor;
            uniform float u_glareRange;
            uniform float u_glareFactor;
            uniform float u_shapeRadius;
            uniform float u_shapeWidth;
            uniform float u_shapeHeight;
            
            out vec4 fragColor;
            
            float sdRoundedBox(vec2 p, vec2 b, float r) {
                vec2 q = abs(p) - b + vec2(r);
                return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec2 mouse = u_mouseSpring / u_resolution;
                
                // Shape distance
                vec2 shapeSize = vec2(u_shapeWidth, u_shapeHeight) / u_resolution;
                float d = sdRoundedBox(uv - mouse, shapeSize * 0.5, u_shapeRadius / u_resolution.x);
                
                // Refraction
                vec2 refOffset = normalize(uv - mouse) * u_refFactor * smoothstep(0.0, -0.1, d);
                vec3 refColor = vec3(
                    texture(u_bg, uv + refOffset * (1.0 + u_refDispersion)).r,
                    texture(u_bg, uv + refOffset).g,
                    texture(u_bg, uv + refOffset * (1.0 - u_refDispersion)).b
                );
                
                // Fresnel
                float fresnel = pow(1.0 - abs(dot(normalize(vec2(uv - mouse)), vec2(0.0, 1.0))), u_refFresnelRange);
                fresnel = smoothstep(0.0, 1.0, fresnel) * u_refFresnelFactor;
                
                // Glare
                float glare = smoothstep(u_glareRange, 0.0, length(uv - mouse)) * u_glareFactor;
                
                // Blend everything
                vec4 blurredBg = texture(u_blurredBg, uv);
                vec4 finalColor = mix(
                    vec4(refColor, 1.0),
                    blurredBg,
                    smoothstep(-0.1, 0.0, d)
                );
                
                finalColor = mix(finalColor, u_tint, fresnel + glare);
                
                fragColor = finalColor;
            }
        `;

        class MultiPassRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2');
                
                if (!this.gl) {
                    throw new Error('WebGL2 not supported');
                }

                this.programs = {
                    bg: this.createProgram(vertexShaderSource, fragmentBgShaderSource),
                    vBlur: this.createProgram(vertexShaderSource, fragmentVBlurShaderSource),
                    hBlur: this.createProgram(vertexShaderSource, fragmentHBlurShaderSource),
                    main: this.createProgram(vertexShaderSource, fragmentMainShaderSource)
                };

                this.framebuffers = {
                    bg: this.createFramebuffer(),
                    vBlur: this.createFramebuffer(),
                    hBlur: this.createFramebuffer()
                };

                this.createGeometry();
                this.setupBackground();
                this.resize();
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                    return null;
                }

                return program;
            }

            createFramebuffer() {
                const fb = this.gl.createFramebuffer();
                const tex = this.gl.createTexture();
                
                this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
                this.gl.texImage2D(
                    this.gl.TEXTURE_2D, 0, this.gl.RGBA,
                    this.canvas.width, this.canvas.height, 0,
                    this.gl.RGBA, this.gl.UNSIGNED_BYTE, null
                );
                
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
                
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
                this.gl.framebufferTexture2D(
                    this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0,
                    this.gl.TEXTURE_2D, tex, 0
                );
                
                return { framebuffer: fb, texture: tex };
            }

            createGeometry() {
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1,
                ]);
                
                const texCoords = new Float32Array([
                    0, 0,
                    1, 0,
                    0, 1,
                    1, 1,
                ]);

                this.vertexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                this.texCoordBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);
            }

            setupBackground() {
                // Create gradient background
                const bgTexture = this.gl.createTexture();
                this.gl.bindTexture(this.gl.TEXTURE_2D, bgTexture);
                
                const pixels = new Uint8Array([
                    64, 64, 92, 255,    92, 92, 128, 255,
                    92, 92, 128, 255,   128, 128, 164, 255,
                ]);
                
                this.gl.texImage2D(
                    this.gl.TEXTURE_2D, 0, this.gl.RGBA,
                    2, 2, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels
                );
                
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                
                this.bgTexture = bgTexture;
            }

            resize() {
                const dpr = window.devicePixelRatio;
                const width = this.canvas.clientWidth * dpr;
                const height = this.canvas.clientHeight * dpr;
                
                this.canvas.width = width;
                this.canvas.height = height;
                
                Object.values(this.framebuffers).forEach(fb => {
                    this.gl.bindTexture(this.gl.TEXTURE_2D, fb.texture);
                    this.gl.texImage2D(
                        this.gl.TEXTURE_2D, 0, this.gl.RGBA,
                        width, height, 0, this.gl.RGBA,
                        this.gl.UNSIGNED_BYTE, null
                    );
                });
                
                this.gl.viewport(0, 0, width, height);
            }

            render(state) {
                const gl = this.gl;

                // Background pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.bg.framebuffer);
                gl.useProgram(this.programs.bg);
                this.setCommonUniforms(this.programs.bg, state);
                gl.bindTexture(gl.TEXTURE_2D, this.bgTexture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Vertical blur pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.vBlur.framebuffer);
                gl.useProgram(this.programs.vBlur);
                this.setCommonUniforms(this.programs.vBlur, state);
                gl.bindTexture(gl.TEXTURE_2D, this.framebuffers.bg.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Horizontal blur pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.hBlur.framebuffer);
                gl.useProgram(this.programs.hBlur);
                this.setCommonUniforms(this.programs.hBlur, state);
                gl.bindTexture(gl.TEXTURE_2D, this.framebuffers.vBlur.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Main pass
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.useProgram(this.programs.main);
                this.setCommonUniforms(this.programs.main, state);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.framebuffers.bg.texture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.framebuffers.hBlur.texture);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            setCommonUniforms(program, state) {
                const gl = this.gl;
                
                const locations = {
                    resolution: gl.getUniformLocation(program, 'u_resolution'),
                    mouse: gl.getUniformLocation(program, 'u_mouse'),
                    mouseSpring: gl.getUniformLocation(program, 'u_mouseSpring'),
                    time: gl.getUniformLocation(program, 'u_time'),
                };

                gl.uniform2f(locations.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(locations.mouse, state.mouse.x, state.mouse.y);
                gl.uniform2f(locations.mouseSpring, state.mouseSpring.x, state.mouseSpring.y);
                gl.uniform1f(locations.time, state.time);
            }
        }

        // Initialize
        const canvas = document.getElementById('glCanvas');
        const renderer = new MultiPassRenderer(canvas);

        // State management
        const state = {
            mouse: { x: 0, y: 0 },
            mouseSpring: { x: 0, y: 0 },
            time: 0
        };

        // Spring physics
        const springConfig = {
            stiffness: 0.1,
            damping: 0.8
        };

        function updateSpring() {
            const dx = state.mouse.x - state.mouseSpring.x;
            const dy = state.mouse.y - state.mouseSpring.y;
            
            state.mouseSpring.x += dx * springConfig.stiffness;
            state.mouseSpring.y += dy * springConfig.stiffness;
            
            state.mouseSpring.x *= springConfig.damping;
            state.mouseSpring.y *= springConfig.damping;
        }

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            state.mouse.x = (e.clientX - rect.left) * window.devicePixelRatio;
            state.mouse.y = (canvas.height - (e.clientY - rect.top) * window.devicePixelRatio);
        });

        // Animation loop
        function animate(timestamp) {
            state.time = timestamp * 0.001;
            updateSpring();
            renderer.render(state);
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            renderer.resize();
        });

        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>
